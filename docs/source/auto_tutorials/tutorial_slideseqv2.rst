
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/tutorial_slideseqv2.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/scverse/squidpy_notebooks/main?filepath=docs/source/auto_tutorials/tutorial_slideseqv2.ipynb
      :alt: Launch binder
      :width: 150 px

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_tutorial_slideseqv2.py:

Analyze Slide-seqV2 data
========================

This tutorial shows how to apply Squidpy for the analysis of Slide-seqV2 data.

The data used here was obtained from :cite:`Stickels2020-rf`.
We provide a pre-processed subset of the data, in :class:`anndata.AnnData` format.
We would like to thank @tudaga for providing cell-type level annotation.
For details on how it was pre-processed, please refer to the original paper.

.. seealso::

    See :ref:`sphx_glr_auto_tutorials_tutorial_visium_hne.py` and
    :ref:`sphx_glr_auto_tutorials_tutorial_seqfish.py` for additional analysis examples.

Import packages & data
----------------------
To run the notebook locally, create a conda environment as *conda env create -f environment.yml* using this
`environment.yml <https://github.com/scverse/squidpy_notebooks/blob/main/environment.yml>`_.

.. GENERATED FROM PYTHON SOURCE LINES 23-32

.. code-block:: default


    import squidpy as sq

    print(f"squidpy=={sq.__version__}")

    # load the pre-processed dataset
    adata = sq.datasets.slideseqv2()
    adata





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    squidpy==1.2.2

    AnnData object with n_obs × n_vars = 41786 × 4000
        obs: 'barcode', 'x', 'y', 'n_genes_by_counts', 'log1p_n_genes_by_counts', 'total_counts', 'log1p_total_counts', 'pct_counts_in_top_50_genes', 'pct_counts_in_top_100_genes', 'pct_counts_in_top_200_genes', 'pct_counts_in_top_500_genes', 'total_counts_MT', 'log1p_total_counts_MT', 'pct_counts_MT', 'n_counts', 'leiden', 'cluster'
        var: 'MT', 'n_cells_by_counts', 'mean_counts', 'log1p_mean_counts', 'pct_dropout_by_counts', 'total_counts', 'log1p_total_counts', 'n_cells', 'highly_variable', 'highly_variable_rank', 'means', 'variances', 'variances_norm'
        uns: 'cluster_colors', 'hvg', 'leiden', 'leiden_colors', 'neighbors', 'pca', 'spatial_neighbors', 'umap'
        obsm: 'X_pca', 'X_umap', 'deconvolution_results', 'spatial'
        varm: 'PCs'
        obsp: 'connectivities', 'distances', 'spatial_connectivities', 'spatial_distances'



.. GENERATED FROM PYTHON SOURCE LINES 33-35

First, let's visualize cluster annotation in spatial context
with :func:`squidpy.pl.spatial_scatter`.

.. GENERATED FROM PYTHON SOURCE LINES 35-37

.. code-block:: default

    sq.pl.spatial_scatter(adata, color="cluster", size=1, shape=None)




.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_001.png
   :alt: cluster
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 38-59

Neighborhood enrichment analysis
--------------------------------
Similar to other spatial data, we can investigate spatial organization of clusters
in a quantitative way, by computing a neighborhood enrichment score.
You can compute such score with the following function: :func:`squidpy.gr.nhood_enrichment`.
In short, it's an enrichment score on spatial proximity of clusters:
if spots belonging to two different clusters are often close to each other,
then they will have a high score and can be defined as being *enriched*.
On the other hand, if they are far apart, the score will be low
and they can be defined as *depleted*.
This score is based on a permutation-based test, and you can set
the number of permutations with the `n_perms` argument (default is 1000).

Since the function works on a connectivity matrix, we need to compute that as well.
This can be done with :func:`squidpy.gr.spatial_neighbors`.
Please see :ref:`sphx_glr_auto_examples_graph_compute_spatial_neighbors.py` and
:ref:`sphx_glr_auto_examples_graph_compute_nhood_enrichment.py` for more details
of how these functions works.

Finally, we'll directly visualize the results with :func:`squidpy.pl.nhood_enrichment`.
We'll add a dendrogram to the heatmap computed with linkage method *ward*.

.. GENERATED FROM PYTHON SOURCE LINES 59-64

.. code-block:: default


    sq.gr.spatial_neighbors(adata, coord_type="generic")
    sq.gr.nhood_enrichment(adata, cluster_key="cluster")
    sq.pl.nhood_enrichment(adata, cluster_key="cluster", method="single", cmap="inferno", vmin=-50, vmax=100)




.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_002.png
   :alt: Neighborhood enrichment
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/1000 [00:00<?, ?/s]      0%|          | 1/1000 [00:05<1:29:57,  5.40s/]      4%|4         | 41/1000 [00:05<01:31, 10.48/s]       8%|8         | 81/1000 [00:05<00:37, 24.29/s]     12%|#2        | 122/1000 [00:05<00:20, 42.87/s]     16%|#6        | 163/1000 [00:05<00:12, 66.44/s]     20%|##        | 203/1000 [00:05<00:08, 94.41/s]     24%|##4       | 242/1000 [00:06<00:06, 126.07/s]     28%|##8       | 281/1000 [00:06<00:04, 160.79/s]     32%|###2      | 320/1000 [00:06<00:03, 196.50/s]     36%|###6      | 361/1000 [00:06<00:02, 234.76/s]     40%|####      | 401/1000 [00:06<00:02, 268.82/s]     44%|####4     | 442/1000 [00:06<00:01, 299.69/s]     48%|####8     | 482/1000 [00:06<00:01, 323.78/s]     52%|#####2    | 523/1000 [00:06<00:01, 345.76/s]     56%|#####6    | 563/1000 [00:06<00:01, 359.51/s]     60%|######    | 603/1000 [00:06<00:01, 369.53/s]     64%|######4   | 643/1000 [00:07<00:00, 376.42/s]     68%|######8   | 683/1000 [00:07<00:00, 380.88/s]     72%|#######2  | 723/1000 [00:07<00:00, 386.13/s]     76%|#######6  | 763/1000 [00:07<00:00, 388.98/s]     80%|########  | 803/1000 [00:07<00:00, 364.34/s]     84%|########4 | 841/1000 [00:07<00:00, 352.80/s]     88%|########7 | 877/1000 [00:07<00:00, 353.89/s]     91%|#########1| 913/1000 [00:07<00:00, 354.79/s]     95%|#########5| 950/1000 [00:07<00:00, 358.41/s]     99%|#########8| 988/1000 [00:07<00:00, 362.10/s]    100%|##########| 1000/1000 [00:08<00:00, 124.94/s]




.. GENERATED FROM PYTHON SOURCE LINES 65-69

Interestingly, there seems to be an enrichment between the *Endothelial_Tip*,
the *Ependymal* cells. Another putative enrichment is between the *Oligodendrocytes*
and *Polydendrocytes* cells. We can visualize the spatial organization of such clusters.
For this, we'll use :func:`squidpy.pl.spatial_scatter` again.

.. GENERATED FROM PYTHON SOURCE LINES 69-78

.. code-block:: default


    sq.pl.spatial_scatter(
        adata,
        shape=None,
        color="cluster",
        groups=["Endothelial_Tip", "Ependymal", "Oligodendrocytes", "Polydendrocytes"],
        size=3,
    )




.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_003.png
   :alt: cluster
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 79-90

Ripley's statistics
-------------------
In addition to the neighbor enrichment score, we can further investigate spatial
organization of cell types in tissue by means of the Ripley's statistics.
Ripley's statistics allow analyst to evaluate whether a discrete annotation (e.g. cell-type)
appears to be clustered, dispersed or randomly distributed on the area of interest.
In Squidpy, we implement three closely related Ripley's statistics, that can be
easily computed with :func:`squidpy.gr.ripley`. Here, we'll showcase the Ripley's L statistic,
which is a variance-stabilized version of the Ripley's K statistics.
We'll visualize the results with :func:`squidpy.pl.ripley`.
Check :ref:`sphx_glr_auto_examples_graph_compute_ripley.py` for more details.

.. GENERATED FROM PYTHON SOURCE LINES 90-94

.. code-block:: default

    mode = "L"
    sq.gr.ripley(adata, cluster_key="cluster", mode=mode, max_dist=500)
    sq.pl.ripley(adata, cluster_key="cluster", mode=mode)




.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_004.png
   :alt: Ripley's L
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'rocket' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'rocket_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'mako' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'mako_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'icefire' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'icefire_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'vlag' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'vlag_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'flare' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'flare_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'crest' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'crest_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)




.. GENERATED FROM PYTHON SOURCE LINES 95-99

The plot highlight how some cell-types have a more clustered pattern,
like *Astrocytes* and *CA11_CA2_CA3_Subiculum* cells, whereas other have a more
dispersed pattern, like *Mural* cells. To confirm such interpretation, we can
selectively visualize again their spatial organization.

.. GENERATED FROM PYTHON SOURCE LINES 99-101

.. code-block:: default

    sq.pl.spatial_scatter(adata, color="cluster", groups=["Mural", "CA1_CA2_CA3_Subiculum"], size=3, shape=None)




.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_005.png
   :alt: cluster
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 102-123

Ligand-receptor interaction analysis
------------------------------------
The analysis showed above has provided us with quantitative information on
cellular organization and communication at the tissue level.
We might be interested in getting a list of potential candidates that might be driving
such cellular communication.
This naturally translates in doing a ligand-receptor interaction analysis.
In Squidpy, we provide a fast re-implementation the popular method CellPhoneDB :cite:`cellphonedb`
(`code <https://github.com/Teichlab/cellphonedb>`_ )
and extended its database of annotated ligand-receptor interaction pairs with
the popular database *Omnipath* :cite:`omnipath`.
You can run the analysis for all clusters pairs, and all genes (in seconds,
without leaving this notebook), with :func:`squidpy.gr.ligrec`.

Let's perform the analysis and visualize the result for three clusters of
interest: *Polydendrocytes* and *Oligodendrocytes*.
For the visualization, we will filter out annotations
with low-expressed genes (with the ``means_range`` argument)
and decreasing the threshold
for the adjusted p-value (with the ``alpha`` argument)
Check :ref:`sphx_glr_auto_examples_graph_compute_ligrec.py` for more details.

.. GENERATED FROM PYTHON SOURCE LINES 123-138

.. code-block:: default

    sq.gr.ligrec(
        adata,
        n_perms=100,
        cluster_key="cluster",
        clusters=["Polydendrocytes", "Oligodendrocytes"],
    )
    sq.pl.ligrec(
        adata,
        cluster_key="cluster",
        source_groups="Oligodendrocytes",
        target_groups=["Polydendrocytes"],
        pvalue_threshold=0.05,
        swap_axes=True,
    )




.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_006.png
   :alt: Receptor-ligand test, $-\log_{10} ~ P$, significant $p=0.001$, $log_2(\frac{molecule_1 + molecule_2}{2} + 1)$
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/squidpy/gr/_ligrec.py:391: SettingWithCopyWarning: 
    A value is trying to be set on a copy of a slice from a DataFrame.
    Try using .loc[row_indexer,col_indexer] = value instead

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
      data["clusters"] = data["clusters"].cat.remove_unused_categories()
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/squidpy/gr/_ligrec.py:400: SettingWithCopyWarning: 
    A value is trying to be set on a copy of a slice from a DataFrame.
    Try using .loc[row_indexer,col_indexer] = value instead

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
      data["clusters"] = cat.rename_categories(cluster_mapper)
      0%|          | 0/100 [00:00<?, ?permutation/s]      1%|1         | 1/100 [00:06<10:42,  6.49s/permutation]     31%|###1      | 31/100 [00:06<00:10,  6.61permutation/s]     60%|######    | 60/100 [00:06<00:02, 15.06permutation/s]     89%|########9 | 89/100 [00:06<00:00, 26.28permutation/s]    100%|##########| 100/100 [00:06<00:00, 14.64permutation/s]




.. GENERATED FROM PYTHON SOURCE LINES 139-144

The dotplot visualization provides an interesting set of candidate interactions
that could be involved in the tissue organization of the cell types of interest.
It should be noted that this method is a pure re-implementation of the original
permutation-based test, and therefore retains all its caveats
and should be interpreted accordingly.

.. GENERATED FROM PYTHON SOURCE LINES 146-155

Spatially variable genes with spatial autocorrelation statistics
----------------------------------------------------------------
Lastly, with Squidpy we can investigate spatial variability of gene expression.
:func:`squidpy.gr.spatial_autocorr` conveniently wraps two
spatial autocorrelation statistics: *Moran's I* and *Geary's C**.
They provide a score on the degree of spatial variability of gene expression.
The statistic as well as the p-value are computed for each gene, and FDR correction
is performed. For the purpose of this tutorial, let's compute the *Moran's I* score.
See :ref:`sphx_glr_auto_examples_graph_compute_moran.py` for more details.

.. GENERATED FROM PYTHON SOURCE LINES 155-158

.. code-block:: default

    sq.gr.spatial_autocorr(adata, mode="moran")
    adata.uns["moranI"].head(10)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>I</th>
          <th>pval_norm</th>
          <th>var_norm</th>
          <th>pval_norm_fdr_bh</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>Ttr</th>
          <td>0.703289</td>
          <td>0.0</td>
          <td>0.000008</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>Plp1</th>
          <td>0.531680</td>
          <td>0.0</td>
          <td>0.000008</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>Mbp</th>
          <td>0.495970</td>
          <td>0.0</td>
          <td>0.000008</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>Hpca</th>
          <td>0.490302</td>
          <td>0.0</td>
          <td>0.000008</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>Enpp2</th>
          <td>0.455090</td>
          <td>0.0</td>
          <td>0.000008</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>1500015O10Rik</th>
          <td>0.453225</td>
          <td>0.0</td>
          <td>0.000008</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>Pcp4</th>
          <td>0.428500</td>
          <td>0.0</td>
          <td>0.000008</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>Sst</th>
          <td>0.398053</td>
          <td>0.0</td>
          <td>0.000008</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>Ptgds</th>
          <td>0.385718</td>
          <td>0.0</td>
          <td>0.000008</td>
          <td>0.0</td>
        </tr>
        <tr>
          <th>Nrgn</th>
          <td>0.368533</td>
          <td>0.0</td>
          <td>0.000008</td>
          <td>0.0</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 159-161

The results are stored in `adata.uns["moranI"]` and we can visualize selected genes
with :func:`squidpy.pl.spatial_scatter`.

.. GENERATED FROM PYTHON SOURCE LINES 161-167

.. code-block:: default

    sq.pl.spatial_scatter(
        adata,
        shape=None,
        color=["Ttr", "Plp1", "Mbp", "Hpca", "Enpp2"],
        size=0.1,
    )



.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_007.png
   :alt: Ttr, Plp1, Mbp, Hpca, Enpp2
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_slideseqv2_007.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  21.566 seconds)

**Estimated memory usage:**  1931 MB


.. _sphx_glr_download_auto_tutorials_tutorial_slideseqv2.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_slideseqv2.py <tutorial_slideseqv2.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_slideseqv2.ipynb <tutorial_slideseqv2.ipynb>`
