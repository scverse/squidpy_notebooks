
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/tutorial_merfish.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/theislab/squidpy_notebooks/master?filepath=docs/source/auto_tutorials/tutorial_merfish.ipynb
      :alt: Launch binder
      :width: 150 px

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_tutorial_merfish.py:

Analyze Merfish data
========================

This tutorial shows how to apply Squidpy for the analysis of Merfish data.

The data used here was obtained from :cite:`Moffitt2018-me`.
We provide a pre-processed subset of the data, in :class:`anndata.AnnData` format.
For details on how it was pre-processed, please refer to the original paper.

.. seealso::

    See :ref:`sphx_glr_auto_tutorials_tutorial_slideseqv2.py` and
    :ref:`sphx_glr_auto_tutorials_tutorial_seqfish.py` for additional analysis examples.

Import packages & data
----------------------
To run the notebook locally, create a conda environment as *conda env create -f environment.yml* using this
`environment.yml <https://github.com/theislab/squidpy_notebooks/blob/master/environment.yml>`_.

.. GENERATED FROM PYTHON SOURCE LINES 22-33

.. code-block:: default


    import scanpy as sc
    import squidpy as sq

    sc.logging.print_header()
    print(f"squidpy=={sq.__version__}")

    # load the pre-processed dataset
    adata = sq.datasets.merfish()
    adata





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    scanpy==1.8.0 anndata==0.7.6 umap==0.5.1 numpy==1.21.0 scipy==1.7.0 pandas==1.2.5 scikit-learn==0.24.2 statsmodels==0.12.2 python-igraph==0.9.6 pynndescent==0.5.2
    squidpy==1.0.1
      0%|          | 0.00/49.2M [00:00<?, ?B/s]      0%|          | 48.0k/49.2M [00:00<02:26, 351kB/s]      0%|          | 184k/49.2M [00:00<01:10, 725kB/s]       2%|1         | 808k/49.2M [00:00<00:20, 2.46MB/s]      7%|6         | 3.21M/49.2M [00:00<00:05, 8.57MB/s]     18%|#8        | 8.90M/49.2M [00:00<00:02, 20.7MB/s]     29%|##9       | 14.3M/49.2M [00:00<00:01, 27.3MB/s]     40%|####      | 19.9M/49.2M [00:00<00:00, 31.8MB/s]     52%|#####1    | 25.4M/49.2M [00:01<00:00, 34.8MB/s]     63%|######3   | 31.2M/49.2M [00:01<00:00, 37.3MB/s]     75%|#######5  | 37.1M/49.2M [00:01<00:00, 39.2MB/s]     87%|########7 | 42.9M/49.2M [00:01<00:00, 40.5MB/s]     99%|#########9| 48.8M/49.2M [00:01<00:00, 41.5MB/s]    100%|##########| 49.2M/49.2M [00:01<00:00, 30.3MB/s]

    AnnData object with n_obs × n_vars = 73655 × 161
        obs: 'Cell_ID', 'Animal_ID', 'Animal_sex', 'Behavior', 'Bregma', 'Centroid_X', 'Centroid_Y', 'Cell_class', 'Neuron_cluster_ID', 'batch'
        uns: 'Cell_class_colors'
        obsm: 'spatial', 'spatial3d'



.. GENERATED FROM PYTHON SOURCE LINES 34-38

This datasets consists of consecutive slices from the mouse hypothalamic preoptic region.
It represents an interesting example of how to work with 3D spatial data in Squidpy.
Let's start with visualization: we can either visualize the 3D stack of slides
using :func:`scanpy.pl.embedding`:

.. GENERATED FROM PYTHON SOURCE LINES 38-40

.. code-block:: default

    sc.pl.embedding(adata, basis="spatial3d", projection="3d", color="Cell_class")




.. image:: /auto_tutorials/images/sphx_glr_tutorial_merfish_001.png
    :alt: Cell_class
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 41-43

Or visualize a single slide with :func:`scanpy.pl.spatial`. Here the slide identifier
is stored in `adata.obs["Bregma"]`, see original paper for definition.

.. GENERATED FROM PYTHON SOURCE LINES 43-46

.. code-block:: default


    sc.pl.spatial(adata[adata.obs.Bregma == -9], color="Cell_class", spot_size=0.01)




.. image:: /auto_tutorials/images/sphx_glr_tutorial_merfish_002.png
    :alt: Cell_class
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 47-60

Neighborhood enrichment analysis in 3D
--------------------------------------
It is important to consider whether the analysis should be performed on the 3D
spatial coordinates or the 2D coordinates for a single slice. Functions that
make use of the spatial graph can already support 3D coordinates, but it is important
to consider that the z-stack coordinate is in the same unit metrics as the x, y coordinates.
Let's start with the neighborhood enrichment score. You can read more on the function
in the docs at :ref:`sphx_glr_auto_examples_graph_compute_spatial_neighbors.py`.
First, we need to compute a neighbor graph with :func:`squidpy.gr.spatial_neighbors`.
If we want to compute the neighbor graph on the 3D coordinate space,
we need to specify ``spatial_key = "spatial3d"``.
Then we can use :func:`squidpy.gr.nhood_enrichment` to compute the score, and visualize
it with :func:`squidpy.gr.nhood_enrichment`.

.. GENERATED FROM PYTHON SOURCE LINES 60-64

.. code-block:: default

    sq.gr.spatial_neighbors(adata, coord_type="generic", spatial_key="spatial3d")
    sq.gr.nhood_enrichment(adata, cluster_key="Cell_class")
    sq.pl.nhood_enrichment(adata, cluster_key="Cell_class", method="single", cmap="inferno", vmin=-50, vmax=100)




.. image:: /auto_tutorials/images/sphx_glr_tutorial_merfish_003.png
    :alt: Neighborhood enrichment
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/scipy/sparse/_index.py:125: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil_matrix is more efficient.
      self._set_arrayXarray(i, j, x)
      0%|          | 0/1000 [00:00<?, ?/s]      1%|          | 6/1000 [00:00<00:16, 59.60/s]      2%|2         | 23/1000 [00:00<00:07, 124.35/s]      4%|4         | 41/1000 [00:00<00:06, 146.82/s]      6%|5         | 58/1000 [00:00<00:06, 154.19/s]      8%|7         | 75/1000 [00:00<00:05, 156.23/s]      9%|9         | 92/1000 [00:00<00:05, 157.60/s]     11%|#         | 109/1000 [00:00<00:05, 160.13/s]     13%|#2        | 126/1000 [00:00<00:05, 161.82/s]     14%|#4        | 143/1000 [00:00<00:05, 162.28/s]     16%|#6        | 160/1000 [00:01<00:05, 161.09/s]     18%|#7        | 177/1000 [00:01<00:05, 157.81/s]     19%|#9        | 193/1000 [00:01<00:05, 152.17/s]     21%|##        | 209/1000 [00:01<00:05, 143.36/s]     22%|##2       | 225/1000 [00:01<00:05, 146.39/s]     24%|##4       | 241/1000 [00:01<00:05, 148.63/s]     26%|##5       | 258/1000 [00:01<00:04, 153.59/s]     28%|##7       | 276/1000 [00:01<00:04, 158.67/s]     29%|##9       | 293/1000 [00:01<00:04, 160.03/s]     31%|###1      | 310/1000 [00:02<00:04, 160.81/s]     33%|###2      | 327/1000 [00:02<00:04, 160.35/s]     34%|###4      | 344/1000 [00:02<00:04, 161.61/s]     36%|###6      | 361/1000 [00:02<00:03, 160.15/s]     38%|###7      | 378/1000 [00:02<00:03, 156.71/s]     39%|###9      | 394/1000 [00:02<00:03, 156.51/s]     41%|####1     | 410/1000 [00:02<00:03, 157.44/s]     43%|####2     | 427/1000 [00:02<00:03, 158.74/s]     44%|####4     | 444/1000 [00:02<00:03, 159.44/s]     46%|####6     | 462/1000 [00:02<00:03, 162.76/s]     48%|####7     | 479/1000 [00:03<00:03, 162.62/s]     50%|####9     | 496/1000 [00:03<00:03, 164.38/s]     51%|#####1    | 514/1000 [00:03<00:02, 166.63/s]     53%|#####3    | 531/1000 [00:03<00:02, 166.86/s]     55%|#####4    | 548/1000 [00:03<00:02, 166.71/s]     56%|#####6    | 565/1000 [00:03<00:02, 166.33/s]     58%|#####8    | 583/1000 [00:03<00:02, 167.06/s]     60%|######    | 601/1000 [00:03<00:02, 169.26/s]     62%|######1   | 618/1000 [00:03<00:02, 168.51/s]     64%|######3   | 635/1000 [00:04<00:02, 165.98/s]     65%|######5   | 652/1000 [00:04<00:02, 159.09/s]     67%|######6   | 669/1000 [00:04<00:02, 161.20/s]     69%|######8   | 687/1000 [00:04<00:01, 164.13/s]     70%|#######   | 705/1000 [00:04<00:01, 167.15/s]     72%|#######2  | 722/1000 [00:04<00:01, 167.64/s]     74%|#######3  | 739/1000 [00:04<00:01, 166.30/s]     76%|#######5  | 756/1000 [00:04<00:01, 166.87/s]     77%|#######7  | 773/1000 [00:04<00:01, 165.84/s]     79%|#######9  | 793/1000 [00:04<00:01, 174.26/s]     81%|########1 | 811/1000 [00:05<00:01, 167.62/s]     83%|########2 | 828/1000 [00:05<00:01, 166.57/s]     84%|########4 | 845/1000 [00:05<00:00, 164.34/s]     86%|########6 | 862/1000 [00:05<00:00, 163.19/s]     88%|########8 | 880/1000 [00:05<00:00, 166.73/s]     90%|########9 | 899/1000 [00:05<00:00, 167.72/s]     92%|#########1| 916/1000 [00:05<00:00, 166.91/s]     93%|#########3| 933/1000 [00:05<00:00, 166.93/s]     95%|#########5| 950/1000 [00:05<00:00, 167.76/s]     97%|#########6| 967/1000 [00:05<00:00, 166.45/s]     98%|#########8| 984/1000 [00:06<00:00, 163.66/s]    100%|##########| 1000/1000 [00:06<00:00, 161.31/s]
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/squidpy/pl/_utils.py:573: MatplotlibDeprecationWarning: In a future version, 'pad' will default to rcParams['figure.subplot.hspace'].  Set pad=0 to keep the old behavior.
      col_ax = divider.append_axes("top", size="5%")




.. GENERATED FROM PYTHON SOURCE LINES 65-68

We can visualize some of the co-enriched clusters with :func:`scanpy.pl.embedding`.
We will set `na_colors=(1,1,1,0)` to make transparent the other observations,
in order to better visualize the clusters of interests across z-stacks.

.. GENERATED FROM PYTHON SOURCE LINES 68-77

.. code-block:: default

    sc.pl.embedding(
        adata,
        basis="spatial3d",
        groups=["OD Mature 1", "OD Mature 2", "OD Mature 4"],
        na_color=(1, 1, 1, 0),
        projection="3d",
        color="Cell_class",
    )




.. image:: /auto_tutorials/images/sphx_glr_tutorial_merfish_004.png
    :alt: Cell_class
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 78-80

We can also visualize gene expression in 3D coordinates. Let's perform differential
expression testing with :func:`scanpy.tl.rank_genes_groups` and visualize the results

.. GENERATED FROM PYTHON SOURCE LINES 80-83

.. code-block:: default

    sc.tl.rank_genes_groups(adata, groupby="Cell_class")
    sc.pl.rank_genes_groups(adata, groupby="Cell_class")




.. image:: /auto_tutorials/images/sphx_glr_tutorial_merfish_005.png
    :alt: Ambiguous vs. rest, Astrocyte vs. rest, Endothelial 1 vs. rest, Endothelial 2 vs. rest, Endothelial 3 vs. rest, Ependymal vs. rest, Excitatory vs. rest, Inhibitory vs. rest, Microglia vs. rest, OD Immature 1 vs. rest, OD Immature 2 vs. rest, OD Mature 1 vs. rest, OD Mature 2 vs. rest, OD Mature 3 vs. rest, OD Mature 4 vs. rest, Pericytes vs. rest
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 84-85

and the expression in 3D.

.. GENERATED FROM PYTHON SOURCE LINES 85-87

.. code-block:: default

    sc.pl.embedding(adata, basis="spatial3d", projection="3d", color=["Gad1", "Mlc1"])




.. image:: /auto_tutorials/images/sphx_glr_tutorial_merfish_006.png
    :alt: Gad1, Mlc1
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 88-91

If the same analysis should be performed on a single slice, then it is advisable to
copy the sample of interest in a new :class:`anndata.AnnData` and use it as
a standard 2D spatial data object.

.. GENERATED FROM PYTHON SOURCE LINES 91-101

.. code-block:: default

    adata_slice = adata[adata.obs.Bregma == -9].copy()
    sq.gr.spatial_neighbors(adata_slice, coord_type="generic")
    sq.gr.nhood_enrichment(adata, cluster_key="Cell_class")
    sc.pl.spatial(
        adata_slice,
        color="Cell_class",
        groups=["Ependymal", "Pericytes", "Endothelial 2"],
        spot_size=0.01,
    )




.. image:: /auto_tutorials/images/sphx_glr_tutorial_merfish_007.png
    :alt: Cell_class
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/scipy/sparse/_index.py:125: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil_matrix is more efficient.
      self._set_arrayXarray(i, j, x)
      0%|          | 0/1000 [00:00<?, ?/s]      1%|          | 7/1000 [00:00<00:14, 67.44/s]      2%|2         | 24/1000 [00:00<00:07, 124.69/s]      4%|4         | 41/1000 [00:00<00:06, 141.47/s]      6%|5         | 58/1000 [00:00<00:06, 150.14/s]      8%|7         | 75/1000 [00:00<00:05, 154.89/s]      9%|9         | 91/1000 [00:00<00:05, 156.34/s]     11%|#         | 108/1000 [00:00<00:05, 157.74/s]     12%|#2        | 125/1000 [00:00<00:05, 157.51/s]     14%|#4        | 142/1000 [00:00<00:05, 159.74/s]     16%|#5        | 158/1000 [00:01<00:05, 159.69/s]     17%|#7        | 174/1000 [00:01<00:05, 159.29/s]     19%|#9        | 192/1000 [00:01<00:04, 162.84/s]     21%|##        | 209/1000 [00:01<00:04, 164.88/s]     23%|##2       | 226/1000 [00:01<00:04, 164.62/s]     24%|##4       | 243/1000 [00:01<00:04, 162.97/s]     26%|##6       | 261/1000 [00:01<00:04, 166.45/s]     28%|##8       | 280/1000 [00:01<00:04, 168.04/s]     30%|##9       | 297/1000 [00:01<00:04, 166.92/s]     31%|###1      | 314/1000 [00:01<00:04, 165.91/s]     33%|###3      | 331/1000 [00:02<00:04, 164.20/s]     35%|###4      | 348/1000 [00:02<00:03, 163.19/s]     36%|###6      | 365/1000 [00:02<00:03, 163.03/s]     38%|###8      | 382/1000 [00:02<00:03, 162.96/s]     40%|###9      | 399/1000 [00:02<00:03, 164.92/s]     42%|####1     | 416/1000 [00:02<00:03, 165.27/s]     43%|####3     | 434/1000 [00:02<00:03, 166.47/s]     45%|####5     | 451/1000 [00:02<00:03, 166.78/s]     47%|####6     | 469/1000 [00:02<00:03, 168.91/s]     49%|####8     | 486/1000 [00:03<00:03, 158.59/s]     50%|#####     | 503/1000 [00:03<00:03, 161.46/s]     52%|#####2    | 520/1000 [00:03<00:02, 162.32/s]     54%|#####3    | 537/1000 [00:03<00:02, 163.29/s]     56%|#####5    | 555/1000 [00:03<00:02, 164.81/s]     57%|#####7    | 572/1000 [00:03<00:02, 164.36/s]     59%|#####8    | 589/1000 [00:03<00:02, 164.46/s]     61%|######    | 606/1000 [00:03<00:02, 163.92/s]     62%|######2   | 623/1000 [00:03<00:02, 163.90/s]     64%|######4   | 640/1000 [00:03<00:02, 162.42/s]     66%|######5   | 657/1000 [00:04<00:02, 161.70/s]     67%|######7   | 674/1000 [00:04<00:02, 160.81/s]     69%|######9   | 691/1000 [00:04<00:01, 160.67/s]     71%|#######   | 708/1000 [00:04<00:01, 161.81/s]     72%|#######2  | 725/1000 [00:04<00:01, 163.37/s]     74%|#######4  | 743/1000 [00:04<00:01, 166.36/s]     76%|#######6  | 760/1000 [00:04<00:01, 167.32/s]     78%|#######7  | 779/1000 [00:04<00:01, 168.60/s]     80%|#######9  | 796/1000 [00:04<00:01, 168.63/s]     81%|########1 | 813/1000 [00:05<00:01, 168.52/s]     83%|########2 | 830/1000 [00:05<00:01, 168.18/s]     85%|########4 | 847/1000 [00:05<00:00, 160.43/s]     86%|########6 | 864/1000 [00:05<00:00, 162.52/s]     88%|########8 | 881/1000 [00:05<00:00, 163.30/s]     90%|########9 | 899/1000 [00:05<00:00, 160.77/s]     92%|#########1| 917/1000 [00:05<00:00, 164.18/s]     93%|#########3| 934/1000 [00:05<00:00, 162.44/s]     95%|#########5| 951/1000 [00:05<00:00, 159.14/s]     97%|#########6| 968/1000 [00:05<00:00, 160.84/s]     98%|#########8| 985/1000 [00:06<00:00, 160.91/s]    100%|##########| 1000/1000 [00:06<00:00, 162.11/s]




.. GENERATED FROM PYTHON SOURCE LINES 102-113

Spatially variable genes with spatial autocorrelation statistics
----------------------------------------------------------------
With Squidpy we can investigate spatial variability of gene expression.
This is an example of a function that only supports 2D data.
:func:`squidpy.gr.spatial_autocorr` conveniently wraps two
spatial autocorrelation statistics: *Moran's I* and *Geary's C*.
They provide a score on the degree of spatial variability of gene expression.
The statistic as well as the p-value are computed for each gene, and FDR correction
is performed. For the purpose of this tutorial, let's compute the *Moran's I* score.
The results are stored in `adata.uns['moranI']` and we can visualize selected genes
with :func:`scanpy.pl.spatial`.

.. GENERATED FROM PYTHON SOURCE LINES 113-120

.. code-block:: default

    sq.gr.spatial_autocorr(adata_slice, mode="moran")
    adata_slice.uns["moranI"].head()
    sc.pl.spatial(
        adata_slice,
        color=["Cd24a", "Necab1", "Mlc1"],
        spot_size=0.01,
    )



.. image:: /auto_tutorials/images/sphx_glr_tutorial_merfish_008.png
    :alt: Cd24a, Necab1, Mlc1
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/scanpy/metrics/_gearys_c.py:293: UserWarning: 1 variables were constant, will return nan for these.
      warnings.warn(





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  34.885 seconds)

**Estimated memory usage:**  8 MB


.. _sphx_glr_download_auto_tutorials_tutorial_merfish.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_merfish.py <tutorial_merfish.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_merfish.ipynb <tutorial_merfish.ipynb>`
