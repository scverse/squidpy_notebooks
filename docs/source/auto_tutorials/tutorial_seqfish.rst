
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/tutorial_seqfish.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/theislab/squidpy_notebooks/master?filepath=docs/source/auto_tutorials/tutorial_seqfish.ipynb
      :alt: Launch binder
      :width: 150 px

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_tutorial_seqfish.py:

Analyze seqFISH data
====================

This tutorial shows how to apply Squidpy for the analysis of seqFISH data.

The data used here was obtained from :cite:`lohoff2020highly`.
We provide a pre-processed subset of the data, in :class:`anndata.AnnData` format.
For details on how it was pre-processed, please refer to the original paper.

.. seealso::

    See :ref:`sphx_glr_auto_tutorials_tutorial_imc.py` for additional analysis examples.

Import packages & data
----------------------
To run the notebook locally, create a conda environment as *conda env create -f environment.yml* using this
`environment.yml <https://github.com/theislab/squidpy_notebooks/blob/master/environment.yml>`_.

.. GENERATED FROM PYTHON SOURCE LINES 21-33

.. code-block:: default


    import scanpy as sc
    import squidpy as sq

    import numpy as np

    sc.logging.print_header()
    print(f"squidpy=={sq.__version__}")

    # load the pre-processed dataset
    adata = sq.datasets.seqfish()





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    scanpy==1.8.0 anndata==0.7.6 umap==0.5.1 numpy==1.21.0 scipy==1.7.0 pandas==1.2.5 scikit-learn==0.24.2 statsmodels==0.12.2 python-igraph==0.9.6 pynndescent==0.5.2
    squidpy==1.0.1
      0%|          | 0.00/30.7M [00:00<?, ?B/s]      0%|          | 56.0k/30.7M [00:00<01:18, 411kB/s]      1%|          | 176k/30.7M [00:00<00:46, 683kB/s]       2%|2         | 632k/30.7M [00:00<00:16, 1.89MB/s]      8%|7         | 2.45M/30.7M [00:00<00:04, 6.52MB/s]     25%|##5       | 7.74M/30.7M [00:00<00:01, 19.7MB/s]     36%|###6      | 11.1M/30.7M [00:00<00:00, 24.1MB/s]     53%|#####2    | 16.3M/30.7M [00:00<00:00, 31.5MB/s]     66%|######5   | 20.1M/30.7M [00:00<00:00, 34.0MB/s]     81%|########1 | 24.9M/30.7M [00:01<00:00, 37.6MB/s]     94%|#########4| 28.9M/30.7M [00:01<00:00, 38.8MB/s]    100%|##########| 30.7M/30.7M [00:01<00:00, 26.4MB/s]




.. GENERATED FROM PYTHON SOURCE LINES 34-36

First, let's visualize cluster annotation in spatial context
with :func:`scanpy.pl.spatial`.

.. GENERATED FROM PYTHON SOURCE LINES 36-38

.. code-block:: default

    sc.pl.spatial(adata, color="celltype_mapped_refined", spot_size=0.03)




.. image:: /auto_tutorials/images/sphx_glr_tutorial_seqfish_001.png
    :alt: celltype_mapped_refined
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 39-59

Neighborhood enrichment analysis
--------------------------------
Similar to other spatial data, we can investigate spatial organization of clusters
in a quantitative way, by computing a neighborhood enrichment score.
You can compute such score with the following function: :func:`squidpy.gr.nhood_enrichment`.
In short, it's an enrichment score on spatial proximity of clusters:
if spots belonging to two different clusters are often close to each other,
then they will have a high score and can be defined as being *enriched*.
On the other hand, if they are far apart, the score will be low
and they can be defined as *depleted*.
This score is based on a permutation-based test, and you can set
the number of permutations with the `n_perms` argument (default is 1000).

Since the function works on a connectivity matrix, we need to compute that as well.
This can be done with :func:`squidpy.gr.spatial_neighbors`.
Please see :ref:`sphx_glr_auto_examples_graph_compute_spatial_neighbors.py` for more details
of how this function works.

Finally, we'll directly visualize the results with :func:`squidpy.pl.nhood_enrichment`.
We'll add a dendrogram to the heatmap computed with linkage method *ward*.

.. GENERATED FROM PYTHON SOURCE LINES 59-63

.. code-block:: default

    sq.gr.spatial_neighbors(adata, coord_type="generic")
    sq.gr.nhood_enrichment(adata, cluster_key="celltype_mapped_refined")
    sq.pl.nhood_enrichment(adata, cluster_key="celltype_mapped_refined", method="ward")




.. image:: /auto_tutorials/images/sphx_glr_tutorial_seqfish_002.png
    :alt: Neighborhood enrichment
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/scipy/sparse/_index.py:125: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil_matrix is more efficient.
      self._set_arrayXarray(i, j, x)
      0%|          | 0/1000 [00:00<?, ?/s]      3%|3         | 31/1000 [00:00<00:03, 298.57/s]      7%|6         | 67/1000 [00:00<00:02, 331.64/s]     10%|#         | 102/1000 [00:00<00:02, 335.13/s]     15%|#4        | 147/1000 [00:00<00:02, 374.39/s]     18%|#8        | 185/1000 [00:00<00:02, 356.34/s]     22%|##2       | 221/1000 [00:00<00:02, 344.99/s]     26%|##5       | 256/1000 [00:00<00:02, 333.59/s]     29%|##9       | 293/1000 [00:00<00:02, 343.75/s]     33%|###3      | 331/1000 [00:00<00:01, 353.54/s]     37%|###6      | 367/1000 [00:01<00:01, 351.97/s]     40%|####      | 403/1000 [00:01<00:01, 341.15/s]     44%|####3     | 439/1000 [00:01<00:01, 344.60/s]     48%|####7     | 478/1000 [00:01<00:01, 351.29/s]     51%|#####1    | 514/1000 [00:01<00:01, 352.05/s]     55%|#####5    | 550/1000 [00:01<00:01, 327.37/s]     59%|#####8    | 590/1000 [00:01<00:01, 345.09/s]     62%|######2   | 625/1000 [00:01<00:01, 328.43/s]     87%|########6 | 868/1000 [00:01<00:00, 909.47/s]    100%|##########| 1000/1000 [00:01<00:00, 513.35/s]
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/squidpy/pl/_utils.py:573: MatplotlibDeprecationWarning: In a future version, 'pad' will default to rcParams['figure.subplot.hspace'].  Set pad=0 to keep the old behavior.
      col_ax = divider.append_axes("top", size="5%")




.. GENERATED FROM PYTHON SOURCE LINES 64-80

A similar analysis was performed in the original publication :cite:`lohoff2020highly`,
and we can appreciate to what extent results overlap.
For instance, there seems to be an enrichment between the *Lateral plate mesoderm*,
the *Intermediate mesoderm* and a milder enrichment for *Allantois* cells.
As in the original publication, there also seems to be an association between the *Endothelium* and
the *Haematoendothelial progenitors*.
Of course, results do not perfectly overlap, and this could be due to several factors:

  - the construction of the neighbors graph (which in our case is
    not informed by the radius, as we did not have access to this information).
  - the number of permutation of the neighborhood enrichment
    (500 in the original publication against the default 1000 in our implementation).

We can also visualize the spatial organization of cells again,
and appreciate the proximity of specific cell clusters.
For this, we'll use :func:`scanpy.pl.spatial` again.

.. GENERATED FROM PYTHON SOURCE LINES 80-94

.. code-block:: default

    sc.pl.spatial(
        adata,
        color="celltype_mapped_refined",
        groups=[
            "Endothelium",
            "Haematoendothelial progenitors",
            "Allantois",
            "Lateral plate mesoderm",
            "Intermediate mesoderm",
            "Presomitic mesoderm",
        ],
        spot_size=0.03,
    )




.. image:: /auto_tutorials/images/sphx_glr_tutorial_seqfish_003.png
    :alt: celltype_mapped_refined
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 95-118

Co-occurrence across spatial dimensions
---------------------------------------
In addition to the neighbor enrichment score, we can visualize cluster co-occurrence
in spatial dimensions.
This is a similar analysis of the one presented above,
yet it does not operate on the connectivity matrix,
but on the original spatial coordinates.
The co-occurrence score is defined as:

.. math::

    \frac{p(exp|cond)}{p(exp)}

where :math:`p(exp|cond)` is the conditional probability of observing a
cluster :math:`exp` conditioned on the presence of a cluster :math:`cond`, whereas
:math:`p(exp)` is the probability of observing :math:`exp` in the radius size
of interest. The score is computed across increasing radii size
around each cell in the tissue.

We can compute this score with :func:`squidpy.gr.co_occurrence`
and set the cluster annotation for the conditional probability with
the argument ``clusters``. Then, we visualize the results with
:func:`squidpy.pl.co_occurrence`.

.. GENERATED FROM PYTHON SOURCE LINES 118-126

.. code-block:: default

    sq.gr.co_occurrence(adata, cluster_key="celltype_mapped_refined")
    sq.pl.co_occurrence(
        adata,
        cluster_key="celltype_mapped_refined",
        clusters="Lateral plate mesoderm",
        figsize=(10, 5),
    )




.. image:: /auto_tutorials/images/sphx_glr_tutorial_seqfish_004.png
    :alt: $\frac{p(exp|Lateral plate mesoderm)}{p(exp)}$
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/1 [00:00<?, ?/s]    100%|##########| 1/1 [00:43<00:00, 43.47s/]    100%|##########| 1/1 [00:43<00:00, 43.48s/]
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'rocket' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'rocket_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'mako' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'mako_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'icefire' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'icefire_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'vlag' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'vlag_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'flare' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'flare_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'crest' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'crest_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)




.. GENERATED FROM PYTHON SOURCE LINES 127-136

It seems to recapitulate a previous observation, that there is a co-occurrence between the
conditional cell type annotation *Lateral plate mesoderm* and the clusters
*Intermediate mesoderm* and *Allantois*.
It also seems that at longer distances, there is a co-occurrence of cells belonging to
the *Presomitic mesoderm* cluster. By visualizing the full tissue as before we can indeed
appreciate that these cell types seems to form a defined clusters relatively close
to the *Lateral plate mesoderm* cells.
It should be noted that the distance units corresponds to
the spatial coordinates saved in `adata.obsm['spatial']`.

.. GENERATED FROM PYTHON SOURCE LINES 138-158

Ligand-receptor interaction analysis
------------------------------------
The analysis showed above has provided us with quantitative information on
cellular organization and communication at the tissue level.
We might be interested in getting a list of potential candidates that might be driving
such cellular communication.
This naturally translates in doing a ligand-receptor interaction analysis.
In Squidpy, we provide a fast re-implementation the popular method CellPhoneDB :cite:`cellphonedb`
(`code <https://github.com/Teichlab/cellphonedb>`_)
and extended its database of annotated ligand-receptor interaction pairs with
the popular database *Omnipath* :cite:`omnipath`.
You can run the analysis for all clusters pairs, and all genes (in seconds,
without leaving this notebook), with :func:`squidpy.gr.ligrec`.

Let's perform the analysis and visualize the result for three clusters of
interest: *Lateral plate mesoderm*,
*Intermediate mesoderm* and *Allantois*. For the visualization, we will
filter out annotations
with low-expressed genes (with the ``means_range`` argument)
and decreasing the threshold for the adjusted p-value (with the ``alpha`` argument).

.. GENERATED FROM PYTHON SOURCE LINES 158-173

.. code-block:: default

    sq.gr.ligrec(
        adata,
        n_perms=100,
        cluster_key="celltype_mapped_refined",
    )
    sq.pl.ligrec(
        adata,
        cluster_key="celltype_mapped_refined",
        source_groups="Lateral plate mesoderm",
        target_groups=["Intermediate mesoderm", "Allantois"],
        means_range=(0.3, np.inf),
        alpha=1e-4,
        swap_axes=True,
    )




.. image:: /auto_tutorials/images/sphx_glr_tutorial_seqfish_005.png
    :alt: Receptor-ligand test, $-\log_{10} ~ P$, significant $p=0.0001$, $log_2(\frac{molecule_1 + molecule_2}{2} + 1)$
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0.00/8.93M [00:00<?, ?B/s]      1%|          | 80.0k/8.93M [00:00<00:17, 524kB/s]      4%|4         | 368k/8.93M [00:00<00:06, 1.32MB/s]     16%|#5        | 1.39M/8.93M [00:00<00:02, 3.85MB/s]     57%|#####6    | 5.06M/8.93M [00:00<00:00, 12.0MB/s]    100%|##########| 8.93M/8.93M [00:00<00:00, 13.0MB/s]
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/omnipath/_core/requests/interactions/_interactions.py:377: DtypeWarning: Columns (8) have mixed types.Specify dtype option on import or set low_memory=False.
      return cls(include, exclude=exclude)._get(**kwargs)
    /home/runner/work/squidpy_notebooks/squidpy_notebooks/.tox/docs/lib/python3.8/site-packages/omnipath/_core/requests/_utils.py:155: FutureWarning: The default value of regex will change from True to False in a future version.
      _split_unique_join(data.str.replace(r"[-\w]*:?(\d+)", r"\1")), func=func
      0%|          | 0.00/1.42M [00:00<?, ?B/s]      6%|5         | 80.0k/1.42M [00:00<00:02, 516kB/s]     25%|##5       | 368k/1.42M [00:00<00:00, 1.30MB/s]     83%|########2 | 1.17M/1.42M [00:00<00:00, 3.15MB/s]    100%|##########| 1.42M/1.42M [00:00<00:00, 3.09MB/s]
      0%|          | 0.00/2.63M [00:00<?, ?B/s]      3%|2         | 80.0k/2.63M [00:00<00:05, 523kB/s]     14%|#4        | 384k/2.63M [00:00<00:01, 1.38MB/s]     59%|#####9    | 1.56M/2.63M [00:00<00:00, 4.35MB/s]    100%|##########| 2.63M/2.63M [00:00<00:00, 5.76MB/s]
      0%|          | 0/100 [00:00<?, ?permutation/s]      1%|1         | 1/100 [00:08<14:10,  8.59s/permutation]     45%|####5     | 45/100 [00:08<00:07,  7.31permutation/s]     81%|########1 | 81/100 [00:08<00:01, 15.35permutation/s]    100%|##########| 100/100 [00:08<00:00, 11.35permutation/s]




.. GENERATED FROM PYTHON SOURCE LINES 174-179

The dotplot visualization provides an interesting set of candidate interactions
that could be involved in the tissue organization of the cell types of interest.
It should be noted that this method is a pure re-implementation of the original
permutation-based test, and therefore retains all its caveats
and should be interpreted accordingly.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  46.666 seconds)

**Estimated memory usage:**  1784 MB


.. _sphx_glr_download_auto_tutorials_tutorial_seqfish.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_seqfish.py <tutorial_seqfish.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_seqfish.ipynb <tutorial_seqfish.ipynb>`
