
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/tutorial_mibitof.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/scverse/squidpy_notebooks/main?filepath=docs/source/auto_tutorials/tutorial_mibitof.ipynb
      :alt: Launch binder
      :width: 150 px

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_tutorial_mibitof.py:

Analyze MIBI-TOF image data
===========================

This tutorial shows how to apply Squidpy to MIBI-TOF data.

The data used here comes from a recent paper from :cite:`hartmann2020multiplexed`.
We provide a pre-processed subset of the data, in :class:`anndata.AnnData` format.
For details on how it was pre-processed, please refer to the original paper.

.. seealso::

    See :ref:`sphx_glr_auto_tutorials_tutorial_visium_hne.py` for additional analysis using images
    and :ref:`sphx_glr_auto_tutorials_tutorial_seqfish.py` for analysis using spatial graph functions.

Import packages & data
----------------------
To run the notebook locally, create a conda environment as *conda env create -f environment.yml* using this
`environment.yml <https://github.com/scverse/squidpy_notebooks/blob/main/environment.yml>`_.

.. GENERATED FROM PYTHON SOURCE LINES 22-32

.. code-block:: default


    import scanpy as sc
    import squidpy as sq

    import numpy as np

    import matplotlib.pyplot as plt

    adata = sq.datasets.mibitof()








.. GENERATED FROM PYTHON SOURCE LINES 33-48

The subset of the data we consider here comprises three biopsies colorectal carcinoma biopsies
from different donors, where MIBI-TOF was used to measure single-cell metabolic profiles.
As imaging information, we included three raw image channels:

  - `145_CD45` - a immune cell marker (cyan).
  - `174_CK` - a tumor marker (magenta).
  - `113_vimentin` - a mesenchymal cell marker (yellow).

and a cell segmentation mask provided by the authors of the original paper.

The `adata` object contains three different libraries, one for each biopsy.
The images are contained in ``adata.uns['spatial'][<library_id>]['images']``.
Let us visualize the cluster annotations for each library using :func:`scanpy.pl.spatial`.
For this, we need to subset `adata` to the desired `library_id`, using the mapping from `obs`
to `library_id` provided by ``adata.obs['library_id']``.

.. GENERATED FROM PYTHON SOURCE LINES 48-54

.. code-block:: default


    for library_id in adata.uns["spatial"].keys():
        sc.pl.spatial(
            adata[adata.obs["library_id"] == library_id], color="Cluster", library_id=library_id, title=library_id
        )




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_mibitof_001.png
         :alt: point16
         :srcset: /auto_tutorials/images/sphx_glr_tutorial_mibitof_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_mibitof_002.png
         :alt: point23
         :srcset: /auto_tutorials/images/sphx_glr_tutorial_mibitof_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_mibitof_003.png
         :alt: point8
         :srcset: /auto_tutorials/images/sphx_glr_tutorial_mibitof_003.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 55-60

Let us create an ImageContainer from the images contained in `adata`.
As all three biopsies are already joined in `adata`, let us also create one ImageContainer for
all three biopsies using a z-stack.
For more information on how to use `ImageContainer` with z-stacks, also have a look at
:ref:`sphx_glr_auto_tutorials_tutorial_image_container_zstacks.py`.

.. GENERATED FROM PYTHON SOURCE LINES 60-68

.. code-block:: default

    imgs = []
    for library_id in adata.uns["spatial"].keys():
        img = sq.im.ImageContainer(adata.uns["spatial"][library_id]["images"]["hires"], library_id=library_id)
        img.add_img(adata.uns["spatial"][library_id]["images"]["segmentation"], library_id=library_id, layer="segmentation")
        img["segmentation"].attrs["segmentation"] = True
        imgs.append(img)
    img = sq.im.ImageContainer.concat(imgs)








.. GENERATED FROM PYTHON SOURCE LINES 69-72

Note that we also added the segmentation as an additional layer to `img`, and set the
`segmentation` attribute in the ImageContainer.
This allows visualization of the segmentation layer as a `labels` layer in Napari.

.. GENERATED FROM PYTHON SOURCE LINES 72-74

.. code-block:: default

    img






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    ImageContainer object with 2 layers:<p style='text-indent: 25px; margin-top: 0px; margin-bottom: 0px;'><strong>image</strong>: <em>y</em> (1024), <em>x</em> (1024), <em>z</em> (3), <em>channels</em> (3)</p><p style='text-indent: 25px; margin-top: 0px; margin-bottom: 0px;'><strong>segmentation</strong>: <em>y</em> (1024), <em>x</em> (1024), <em>z</em> (3), <em>channels_0</em> (1)</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 75-81

If you have Napari installed, you can have a look at the data using the interactive viewer:
Note that you can load the segmentation layer as an overlay over the image.

.. code-block:: python

    img.interactive(adata, library_key='library_id')

.. GENERATED FROM PYTHON SOURCE LINES 83-84

Let us also statically visualize the data in `img`, using :func:`squidpy.im.ImageCntainer.show`:

.. GENERATED FROM PYTHON SOURCE LINES 84-87

.. code-block:: default

    img.show("image")
    img.show("image", segmentation_layer="segmentation")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_mibitof_004.png
         :alt: image, library_id:point16, image, library_id:point23, image, library_id:point8
         :srcset: /auto_tutorials/images/sphx_glr_tutorial_mibitof_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_mibitof_005.png
         :alt: image, library_id:point16, image, library_id:point23, image, library_id:point8
         :srcset: /auto_tutorials/images/sphx_glr_tutorial_mibitof_005.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 88-95

In the following we show how to use Squidpy to extract cellular mean intensity information using raw images
and a provided segmentation mask.
In the present case, `adata` of course already contains the post-processed cellular mean intensity
for the raw image channels.
The aim of this tutorial, however, is to showcase how the extraction of such features is possible using Squidpy.
As Squidpy is backed by :mod:`dask` and supports chunked image processing,
also large images can be processed in this way.

.. GENERATED FROM PYTHON SOURCE LINES 97-104

Convert image to CMYK
---------------------
As already mentioned, the images contain information from three raw channels, `145_CD45`,
`174_CK`, and `113_vimentin`.
As the channel information is encoded in CMYK space, we first need to convert the RGB images to CMYK.

For this, we can use :meth:`squidpy.im.ImageContainer.apply`.

.. GENERATED FROM PYTHON SOURCE LINES 104-121

.. code-block:: default



    def rgb2cmyk(arr):
        """Convert arr from RGB to CMYK color space."""
        R = arr[..., 0] / 255
        G = arr[..., 1] / 255
        B = arr[..., 2] / 255
        K = 1 - (np.max(arr, axis=-1) / 255)
        C = (1 - R - K) / (1 - K + np.finfo(float).eps)  # avoid division by 0
        M = (1 - G - K) / (1 - K + np.finfo(float).eps)
        Y = (1 - B - K) / (1 - K + np.finfo(float).eps)
        return np.stack([C, M, Y, K], axis=3)


    img.apply(rgb2cmyk, layer="image", new_layer="image_cmyk", copy=False)
    img.show("image_cmyk", channelwise=True)




.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_mibitof_006.png
   :alt: image_cmyk:0, library_id:point16, image_cmyk:1, library_id:point16, image_cmyk:2, library_id:point16, image_cmyk:3, library_id:point16, image_cmyk:0, library_id:point23, image_cmyk:1, library_id:point23, image_cmyk:2, library_id:point23, image_cmyk:3, library_id:point23, image_cmyk:0, library_id:point8, image_cmyk:1, library_id:point8, image_cmyk:2, library_id:point8, image_cmyk:3, library_id:point8
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_mibitof_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 122-137

Extract per-cell mean intensity
-------------------------------
Now that we have disentangled the individual channels, let use use the provided segmentation mask
to extract per-cell mean intensities.

By default, the `segmentation` feature extractor extracts information using all segments (cells)
in the current crop.
As we would like to only get information of the segment (cell) in the center of the current crop,
let us use a `custom` feature extractor.

Fist, define a custom feature extraction function. This function needs to get the segmentation mask
and the original image as input.
We will achieve this by passing an ``additional_layers`` argument to the `custom` feature extractor.
This special argument will pass the values of every layer in `additional_layers`
to the custom feature extraction function.

.. GENERATED FROM PYTHON SOURCE LINES 137-164

.. code-block:: default



    def segmentation_image_intensity(arr, image_cmyk):
        """
        Calculate per-channel mean intensity of the center segment.

        arr: the segmentation
        image_cmyk: the raw image values
        """
        import skimage.measure

        # the center of the segmentation mask contains the current label
        # use that to calculate the mask
        s = arr.shape[0]
        mask = (arr == arr[s // 2, s // 2, 0, 0]).astype(int)
        # use skimage.measure.regionprops to get the intensity per channel
        features = []
        for c in range(image_cmyk.shape[-1]):
            feature = skimage.measure.regionprops_table(
                np.squeeze(mask),  # skimage needs 3d or 2d images, so squeeze excess dims
                intensity_image=np.squeeze(image_cmyk[:, :, :, c]),
                properties=["mean_intensity"],
            )["mean_intensity"][0]
            features.append(feature)
        return features









.. GENERATED FROM PYTHON SOURCE LINES 165-169

Now, use :func:`squidpy.im.calculate_image_features` with the `custom` feature extractor,
specifying the function (``func``) to use, and the additional layers (``additional_layers``)
to pass to the function.
We will use ``spot_scale = 10`` to ensure that we also cover big segments fully by one crop.

.. GENERATED FROM PYTHON SOURCE LINES 169-179

.. code-block:: default

    sq.im.calculate_image_features(
        adata,
        img,
        library_id="library_id",
        features="custom",
        spot_scale=10,
        layer="segmentation",
        features_kwargs={"custom": {"func": segmentation_image_intensity, "additional_layers": ["image_cmyk"]}},
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/3309 [00:00<?, ?/s]      0%|          | 1/3309 [00:04<4:22:28,  4.76s/]      1%|          | 19/3309 [00:04<10:04,  5.44/s]       1%|1         | 35/3309 [00:04<04:42, 11.60/s]      2%|1         | 53/3309 [00:05<02:37, 20.63/s]      2%|2         | 71/3309 [00:05<01:41, 31.98/s]      3%|2         | 89/3309 [00:05<01:10, 45.50/s]      3%|3         | 109/3309 [00:05<00:50, 63.19/s]      4%|3         | 129/3309 [00:05<00:38, 82.03/s]      5%|4         | 149/3309 [00:05<00:31, 101.12/s]      5%|5         | 169/3309 [00:05<00:26, 119.37/s]      6%|5         | 188/3309 [00:05<00:23, 134.23/s]      6%|6         | 208/3309 [00:05<00:20, 148.54/s]      7%|6         | 228/3309 [00:05<00:19, 160.54/s]      7%|7         | 248/3309 [00:06<00:18, 167.19/s]      8%|8         | 268/3309 [00:06<00:17, 174.25/s]      9%|8         | 288/3309 [00:06<00:16, 179.02/s]      9%|9         | 308/3309 [00:06<00:16, 183.35/s]     10%|9         | 328/3309 [00:06<00:16, 184.37/s]     11%|#         | 348/3309 [00:06<00:15, 186.63/s]     11%|#1        | 368/3309 [00:06<00:15, 188.18/s]     12%|#1        | 388/3309 [00:06<00:15, 188.54/s]     12%|#2        | 408/3309 [00:06<00:15, 189.87/s]     13%|#2        | 428/3309 [00:07<00:15, 187.85/s]     14%|#3        | 448/3309 [00:07<00:15, 189.61/s]     14%|#4        | 468/3309 [00:07<00:14, 189.77/s]     15%|#4        | 488/3309 [00:07<00:14, 191.05/s]     15%|#5        | 508/3309 [00:07<00:14, 191.79/s]     16%|#5        | 528/3309 [00:07<00:14, 190.86/s]     17%|#6        | 548/3309 [00:07<00:14, 188.93/s]     17%|#7        | 567/3309 [00:07<00:14, 189.23/s]     18%|#7        | 587/3309 [00:07<00:14, 190.09/s]     18%|#8        | 607/3309 [00:07<00:14, 189.65/s]     19%|#8        | 626/3309 [00:08<00:14, 188.22/s]     20%|#9        | 646/3309 [00:08<00:14, 188.59/s]     20%|##        | 665/3309 [00:08<00:14, 186.27/s]     21%|##        | 685/3309 [00:08<00:13, 187.95/s]     21%|##1       | 704/3309 [00:08<00:13, 187.82/s]     22%|##1       | 724/3309 [00:08<00:13, 189.52/s]     22%|##2       | 744/3309 [00:08<00:13, 190.43/s]     23%|##3       | 764/3309 [00:08<00:13, 189.92/s]     24%|##3       | 784/3309 [00:08<00:13, 191.00/s]     24%|##4       | 804/3309 [00:09<00:13, 190.82/s]     25%|##4       | 824/3309 [00:09<00:13, 189.17/s]     26%|##5       | 844/3309 [00:09<00:12, 189.66/s]     26%|##6       | 864/3309 [00:09<00:12, 190.85/s]     27%|##6       | 884/3309 [00:09<00:12, 191.56/s]     27%|##7       | 904/3309 [00:09<00:12, 189.64/s]     28%|##7       | 924/3309 [00:09<00:12, 191.28/s]     29%|##8       | 944/3309 [00:09<00:12, 190.38/s]     29%|##9       | 964/3309 [00:09<00:12, 191.45/s]     30%|##9       | 984/3309 [00:09<00:12, 191.74/s]     30%|###       | 1004/3309 [00:10<00:12, 186.47/s]     31%|###       | 1024/3309 [00:10<00:12, 188.56/s]     32%|###1      | 1043/3309 [00:10<00:12, 188.29/s]     32%|###2      | 1063/3309 [00:10<00:11, 189.72/s]     33%|###2      | 1083/3309 [00:10<00:11, 190.23/s]     33%|###3      | 1103/3309 [00:10<00:11, 189.59/s]     34%|###3      | 1123/3309 [00:10<00:11, 191.15/s]     35%|###4      | 1143/3309 [00:10<00:11, 188.75/s]     35%|###5      | 1162/3309 [00:10<00:11, 188.53/s]     36%|###5      | 1181/3309 [00:11<00:11, 184.49/s]     36%|###6      | 1200/3309 [00:11<00:11, 182.71/s]     37%|###6      | 1219/3309 [00:11<00:11, 181.51/s]     37%|###7      | 1238/3309 [00:11<00:11, 182.34/s]     38%|###7      | 1257/3309 [00:11<00:11, 183.09/s]     39%|###8      | 1276/3309 [00:11<00:11, 180.59/s]     39%|###9      | 1295/3309 [00:11<00:11, 181.29/s]     40%|###9      | 1314/3309 [00:11<00:10, 181.52/s]     40%|####      | 1334/3309 [00:11<00:10, 184.70/s]     41%|####      | 1354/3309 [00:11<00:10, 186.55/s]     41%|####1     | 1373/3309 [00:12<00:10, 184.86/s]     42%|####2     | 1393/3309 [00:12<00:10, 186.79/s]     43%|####2     | 1412/3309 [00:12<00:10, 187.07/s]     43%|####3     | 1432/3309 [00:12<00:09, 188.20/s]     44%|####3     | 1451/3309 [00:12<00:09, 187.85/s]     44%|####4     | 1471/3309 [00:12<00:09, 189.29/s]     45%|####5     | 1491/3309 [00:12<00:09, 190.88/s]     46%|####5     | 1511/3309 [00:12<00:09, 189.35/s]     46%|####6     | 1530/3309 [00:12<00:09, 185.94/s]     47%|####6     | 1549/3309 [00:13<00:09, 186.46/s]     47%|####7     | 1568/3309 [00:13<00:09, 185.24/s]     48%|####7     | 1588/3309 [00:13<00:09, 187.54/s]     49%|####8     | 1607/3309 [00:13<00:09, 187.94/s]     49%|####9     | 1627/3309 [00:13<00:08, 189.33/s]     50%|####9     | 1646/3309 [00:13<00:08, 189.20/s]     50%|#####     | 1666/3309 [00:13<00:08, 189.66/s]     51%|#####     | 1686/3309 [00:13<00:08, 189.54/s]     52%|#####1    | 1705/3309 [00:13<00:08, 181.24/s]     52%|#####2    | 1724/3309 [00:13<00:08, 181.95/s]     53%|#####2    | 1743/3309 [00:14<00:08, 183.75/s]     53%|#####3    | 1762/3309 [00:14<00:08, 185.19/s]     54%|#####3    | 1781/3309 [00:14<00:08, 186.54/s]     54%|#####4    | 1801/3309 [00:14<00:07, 189.06/s]     55%|#####5    | 1821/3309 [00:14<00:07, 189.56/s]     56%|#####5    | 1840/3309 [00:14<00:08, 182.61/s]     56%|#####6    | 1860/3309 [00:14<00:07, 186.57/s]     57%|#####6    | 1879/3309 [00:14<00:07, 186.76/s]     57%|#####7    | 1899/3309 [00:14<00:07, 188.61/s]     58%|#####7    | 1919/3309 [00:14<00:07, 189.66/s]     59%|#####8    | 1938/3309 [00:15<00:07, 184.54/s]     59%|#####9    | 1957/3309 [00:15<00:07, 185.69/s]     60%|#####9    | 1977/3309 [00:15<00:07, 187.49/s]     60%|######    | 1997/3309 [00:15<00:06, 188.86/s]     61%|######    | 2016/3309 [00:15<00:06, 188.44/s]     61%|######1   | 2035/3309 [00:15<00:06, 187.38/s]     62%|######2   | 2055/3309 [00:15<00:06, 188.82/s]     63%|######2   | 2074/3309 [00:15<00:06, 188.61/s]     63%|######3   | 2093/3309 [00:15<00:06, 187.00/s]     64%|######3   | 2112/3309 [00:16<00:06, 186.99/s]     64%|######4   | 2131/3309 [00:16<00:06, 187.03/s]     65%|######5   | 2151/3309 [00:16<00:06, 188.24/s]     66%|######5   | 2170/3309 [00:16<00:06, 186.83/s]     66%|######6   | 2189/3309 [00:16<00:06, 186.22/s]     67%|######6   | 2208/3309 [00:16<00:05, 186.13/s]     67%|######7   | 2227/3309 [00:16<00:05, 183.37/s]     68%|######7   | 2246/3309 [00:16<00:05, 181.19/s]     68%|######8   | 2265/3309 [00:16<00:05, 181.40/s]     69%|######9   | 2284/3309 [00:16<00:05, 180.74/s]     70%|######9   | 2303/3309 [00:17<00:05, 181.47/s]     70%|#######   | 2322/3309 [00:17<00:05, 181.68/s]     71%|#######   | 2341/3309 [00:17<00:05, 180.68/s]     71%|#######1  | 2360/3309 [00:17<00:05, 181.68/s]     72%|#######1  | 2379/3309 [00:17<00:05, 180.60/s]     72%|#######2  | 2398/3309 [00:17<00:05, 180.00/s]     73%|#######3  | 2418/3309 [00:17<00:04, 183.07/s]     74%|#######3  | 2437/3309 [00:17<00:04, 183.89/s]     74%|#######4  | 2457/3309 [00:17<00:04, 186.83/s]     75%|#######4  | 2477/3309 [00:18<00:04, 188.59/s]     75%|#######5  | 2497/3309 [00:18<00:04, 188.93/s]     76%|#######6  | 2517/3309 [00:18<00:04, 190.04/s]     77%|#######6  | 2537/3309 [00:18<00:04, 189.70/s]     77%|#######7  | 2557/3309 [00:18<00:03, 190.63/s]     78%|#######7  | 2577/3309 [00:18<00:03, 187.19/s]     78%|#######8  | 2597/3309 [00:18<00:03, 189.05/s]     79%|#######9  | 2617/3309 [00:18<00:03, 189.42/s]     80%|#######9  | 2636/3309 [00:18<00:03, 189.41/s]     80%|########  | 2656/3309 [00:18<00:03, 190.55/s]     81%|########  | 2676/3309 [00:19<00:03, 189.61/s]     81%|########1 | 2696/3309 [00:19<00:03, 190.33/s]     82%|########2 | 2716/3309 [00:19<00:03, 189.44/s]     83%|########2 | 2736/3309 [00:19<00:03, 189.89/s]     83%|########3 | 2756/3309 [00:19<00:02, 190.13/s]     84%|########3 | 2776/3309 [00:19<00:02, 189.31/s]     84%|########4 | 2796/3309 [00:19<00:02, 190.44/s]     85%|########5 | 2816/3309 [00:19<00:02, 190.31/s]     86%|########5 | 2836/3309 [00:19<00:02, 186.35/s]     86%|########6 | 2855/3309 [00:20<00:02, 186.27/s]     87%|########6 | 2875/3309 [00:20<00:02, 188.48/s]     87%|########7 | 2895/3309 [00:20<00:02, 189.81/s]     88%|########8 | 2914/3309 [00:20<00:02, 189.36/s]     89%|########8 | 2934/3309 [00:20<00:01, 189.90/s]     89%|########9 | 2953/3309 [00:20<00:01, 189.07/s]     90%|########9 | 2972/3309 [00:20<00:01, 187.40/s]     90%|######### | 2992/3309 [00:20<00:01, 188.43/s]     91%|######### | 3011/3309 [00:20<00:01, 188.24/s]     92%|#########1| 3031/3309 [00:20<00:01, 189.83/s]     92%|#########2| 3050/3309 [00:21<00:01, 189.37/s]     93%|#########2| 3069/3309 [00:21<00:01, 188.66/s]     93%|#########3| 3089/3309 [00:21<00:01, 189.78/s]     94%|#########3| 3109/3309 [00:21<00:01, 190.55/s]     95%|#########4| 3129/3309 [00:21<00:00, 190.52/s]     95%|#########5| 3149/3309 [00:21<00:00, 189.20/s]     96%|#########5| 3169/3309 [00:21<00:00, 190.42/s]     96%|#########6| 3189/3309 [00:21<00:00, 189.95/s]     97%|#########6| 3209/3309 [00:21<00:00, 190.72/s]     98%|#########7| 3229/3309 [00:21<00:00, 191.17/s]     98%|#########8| 3249/3309 [00:22<00:00, 187.69/s]     99%|#########8| 3268/3309 [00:22<00:00, 186.11/s]     99%|#########9| 3287/3309 [00:22<00:00, 184.31/s]    100%|#########9| 3306/3309 [00:22<00:00, 184.80/s]    100%|##########| 3309/3309 [00:22<00:00, 147.59/s]




.. GENERATED FROM PYTHON SOURCE LINES 180-182

The resulting features are stored in ``adata.obs['img_features']``,
with channel 0 representing `145_CD45`, channel 1 `174_CK`, and channel 2 `113_vimentin`.

.. GENERATED FROM PYTHON SOURCE LINES 182-184

.. code-block:: default

    adata.obsm["img_features"]






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>segmentation_image_intensity_0</th>
          <th>segmentation_image_intensity_1</th>
          <th>segmentation_image_intensity_2</th>
          <th>segmentation_image_intensity_3</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>3034-0</th>
          <td>0.000000</td>
          <td>0.995041</td>
          <td>0.010664</td>
          <td>0.492503</td>
        </tr>
        <tr>
          <th>3035-0</th>
          <td>0.000049</td>
          <td>0.884839</td>
          <td>0.042991</td>
          <td>0.713101</td>
        </tr>
        <tr>
          <th>3036-0</th>
          <td>0.680350</td>
          <td>0.000235</td>
          <td>0.222640</td>
          <td>0.948284</td>
        </tr>
        <tr>
          <th>3037-0</th>
          <td>0.813055</td>
          <td>0.000000</td>
          <td>0.173941</td>
          <td>0.790169</td>
        </tr>
        <tr>
          <th>3038-0</th>
          <td>0.420203</td>
          <td>0.015063</td>
          <td>0.486171</td>
          <td>0.709584</td>
        </tr>
        <tr>
          <th>...</th>
          <td>...</td>
          <td>...</td>
          <td>...</td>
          <td>...</td>
        </tr>
        <tr>
          <th>47342-2</th>
          <td>0.000000</td>
          <td>0.000000</td>
          <td>0.696113</td>
          <td>0.855720</td>
        </tr>
        <tr>
          <th>47343-2</th>
          <td>0.441017</td>
          <td>0.000000</td>
          <td>0.587986</td>
          <td>0.941870</td>
        </tr>
        <tr>
          <th>47344-2</th>
          <td>0.639157</td>
          <td>0.000000</td>
          <td>0.344870</td>
          <td>0.858989</td>
        </tr>
        <tr>
          <th>47345-2</th>
          <td>0.196760</td>
          <td>0.000000</td>
          <td>0.612479</td>
          <td>0.855991</td>
        </tr>
        <tr>
          <th>47346-2</th>
          <td>0.000000</td>
          <td>0.000000</td>
          <td>0.774775</td>
          <td>0.981311</td>
        </tr>
      </tbody>
    </table>
    <p>3309 rows × 4 columns</p>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 185-188

As described in :cite:`hartmann2020multiplexed`, let us transformed using an
inverse hyperbolic sine (`arcsinh`) co-factor of 0.05, to allow us to compare
the computed mean intensities with the values contained in `adata`.

.. GENERATED FROM PYTHON SOURCE LINES 188-190

.. code-block:: default

    adata.obsm["img_features_transformed"] = np.arcsinh(adata.obsm["img_features"] / 0.05)








.. GENERATED FROM PYTHON SOURCE LINES 191-192

Now, let's visualize the result:

.. GENERATED FROM PYTHON SOURCE LINES 192-204

.. code-block:: default

    channels = ["CD45", "CK", "vimentin"]

    fig, axes = plt.subplots(1, 3, figsize=(15, 3))
    for i, ax in enumerate(axes):
        X = np.array(adata[:, channels[i]].X.todense())[:, 0]
        Y = adata.obsm["img_features_transformed"][f"segmentation_image_intensity_{i}"]
        ax.scatter(X, Y)
        ax.set_xlabel("true value in adata.X")
        ax.set_ylabel("computed mean intensity")
        corr = np.corrcoef(X, Y)[1, 0]
        ax.set_title(f"{channels[i]}, corr: {corr:.2f}")




.. image-sg:: /auto_tutorials/images/sphx_glr_tutorial_mibitof_007.png
   :alt: CD45, corr: 0.84, CK, corr: 0.85, vimentin, corr: 0.70
   :srcset: /auto_tutorials/images/sphx_glr_tutorial_mibitof_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 205-215

We get high correlations between the original values and our computation using Squidpy.
The remaining differences are probably due to more pre-processing applied by
the authors of :cite:`hartmann2020multiplexed`.

In this tutorial we have shown how to pre-process imaging data to extract per-cell
counts / mean intensities using Squidpy.
Of course it is also possible to apply spatial statistics functions provided by the
:mod:`squidpy.gr` module to MIBI-TOF data.
For examples of this, please see our other Analysis tutorials, e.g.
:ref:`sphx_glr_auto_tutorials_tutorial_seqfish.py`.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  55.450 seconds)

**Estimated memory usage:**  473 MB


.. _sphx_glr_download_auto_tutorials_tutorial_mibitof.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_mibitof.py <tutorial_mibitof.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_mibitof.ipynb <tutorial_mibitof.ipynb>`
