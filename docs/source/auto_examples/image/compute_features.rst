
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/image/compute_features.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/theislab/squidpy_notebooks/master?filepath=docs/source/auto_examples/image/compute_features.ipynb
      :alt: Launch binder
      :width: 150 px

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_image_compute_features.py:

Extract image features
----------------------

This example shows the computation of spot-wise features from Visium images.

Visium datasets contain high-resolution images of the tissue in addition to the spatial gene expression
measurements per spot (*obs*).
In this notebook, we extract features for each spot from an image using :func:`squidpy.im.calculate_image_features`
and create a **obs x features** matrix that can be analyzed together with
the **obs x genes** spatial gene expression matrix.

.. seealso::

    We provide different feature extractors that are described in more detail in the following examples:

    - See :ref:`sphx_glr_auto_examples_image_compute_summary_features.py` on how to calculate summary statistics
      of each color channel.
    - See :ref:`sphx_glr_auto_examples_image_compute_texture_features.py` on how to calculate texture features based
      on repeating patterns.
    - See :ref:`sphx_glr_auto_examples_image_compute_histogram_features.py` on how to calculate
      color histogram features.
    - See :ref:`sphx_glr_auto_examples_image_compute_segmentation_features.py` on how to calculate
      number and size of objects from a binary segmentation layer.
    - See :ref:`sphx_glr_auto_examples_image_compute_custom_features.py` on how to calculate custom features
      by providing any feature extraction function.

.. GENERATED FROM PYTHON SOURCE LINES 29-41

.. code-block:: default


    import scanpy as sc
    import squidpy as sq

    import numpy as np

    import seaborn as sns

    # get spatial dataset including high-resolution tissue image
    img = sq.datasets.visium_hne_image_crop()
    adata = sq.datasets.visium_hne_adata_crop()





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'rocket' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'rocket_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'mako' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'mako_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'icefire' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'icefire_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'vlag' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'vlag_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'flare' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'flare_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1582: UserWarning: Trying to register the cmap 'crest' which already exists.
      mpl_cm.register_cmap(_name, _cmap)
    /Users/giovanni.palla/Projects/squidpy_notebooks/.tox/docs/lib/python3.9/site-packages/seaborn/cm.py:1583: UserWarning: Trying to register the cmap 'crest_r' which already exists.
      mpl_cm.register_cmap(_name + "_r", _cmap_r)




.. GENERATED FROM PYTHON SOURCE LINES 42-45

The high-resolution tissue image is contained in ``img['image']``,
and the spot locations coordinates are stored in ``adata.obsm['spatial']``.
We can plot the spots overlayed on a lower-resolution version of the tissue image contained in ``adata``.

.. GENERATED FROM PYTHON SOURCE LINES 45-52

.. code-block:: default

    np.set_printoptions(threshold=10)
    print(img)
    print(adata.obsm["spatial"])

    sc.set_figure_params(figsize=(4, 4))
    sc.pl.spatial(adata, add_outline=True)




.. image-sg:: /auto_examples/image/images/sphx_glr_compute_features_001.png
   :alt: compute features
   :srcset: /auto_examples/image/images/sphx_glr_compute_features_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ImageContainer[shape=(3527, 3527), layers=['image']]
    [[1575   98]
     [2538 1774]
     [1850   98]
     ...
     [2263 1534]
     [2401 1055]
     [2676 1774]]




.. GENERATED FROM PYTHON SOURCE LINES 53-66

Using this information, we can now extract features from the tissue underneath each spot by calling
:func:`squidpy.im.calculate_image_features`.
This function takes both ``adata`` and ``img`` as input, and will write the resulting ``obs x features`` matrix to
``adata.obsm[<key>]``.
It contains several arguments to modify its behavior. With these arguments you can:

  - specify the image used for feature calculation using ``layer``.
  - specify the type of features that should be calculated using ``features`` and ``features_kwargs``.
  - specify how the crops used for feature calculation look like using ``kwargs``.
  - specify parallelization options using ``n_jobs``, ``backend``, and ``show_progress_bar``.
  - specify how the data is returned using ``key_added`` and ``copy``.

Let us first calculate summary features and save the result in ``adata.obsm['features']``.

.. GENERATED FROM PYTHON SOURCE LINES 66-71

.. code-block:: default

    sq.im.calculate_image_features(adata, img, features="summary", key_added="features", show_progress_bar=False)

    # show the calculated features
    adata.obsm["features"].head()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>summary_ch-0_quantile-0.9</th>
          <th>summary_ch-0_quantile-0.5</th>
          <th>summary_ch-0_quantile-0.1</th>
          <th>summary_ch-0_mean</th>
          <th>summary_ch-0_std</th>
          <th>summary_ch-1_quantile-0.9</th>
          <th>summary_ch-1_quantile-0.5</th>
          <th>summary_ch-1_quantile-0.1</th>
          <th>summary_ch-1_mean</th>
          <th>summary_ch-1_std</th>
          <th>summary_ch-2_quantile-0.9</th>
          <th>summary_ch-2_quantile-0.5</th>
          <th>summary_ch-2_quantile-0.1</th>
          <th>summary_ch-2_mean</th>
          <th>summary_ch-2_std</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>AAAGACCCAAGTCGCG-1</th>
          <td>140.0</td>
          <td>112.0</td>
          <td>78.0</td>
          <td>110.332029</td>
          <td>24.126489</td>
          <td>108.0</td>
          <td>80.0</td>
          <td>53.0</td>
          <td>80.129908</td>
          <td>21.863844</td>
          <td>140.0</td>
          <td>115.0</td>
          <td>90.0</td>
          <td>115.145057</td>
          <td>19.554108</td>
        </tr>
        <tr>
          <th>AAAGGGATGTAGCAAG-1</th>
          <td>144.0</td>
          <td>114.0</td>
          <td>90.0</td>
          <td>115.557253</td>
          <td>21.279808</td>
          <td>107.0</td>
          <td>77.0</td>
          <td>56.0</td>
          <td>79.957329</td>
          <td>20.546552</td>
          <td>142.0</td>
          <td>111.0</td>
          <td>88.0</td>
          <td>113.362959</td>
          <td>21.422890</td>
        </tr>
        <tr>
          <th>AAAGTCACTGATGTAA-1</th>
          <td>139.0</td>
          <td>115.0</td>
          <td>84.0</td>
          <td>112.740563</td>
          <td>22.550223</td>
          <td>121.0</td>
          <td>94.0</td>
          <td>66.0</td>
          <td>93.735134</td>
          <td>22.459672</td>
          <td>141.0</td>
          <td>118.0</td>
          <td>93.0</td>
          <td>117.298447</td>
          <td>19.089482</td>
        </tr>
        <tr>
          <th>AAATGGCATGTCTTGT-1</th>
          <td>138.0</td>
          <td>109.0</td>
          <td>74.0</td>
          <td>107.372175</td>
          <td>24.896688</td>
          <td>101.0</td>
          <td>71.0</td>
          <td>45.0</td>
          <td>72.320288</td>
          <td>21.589912</td>
          <td>142.0</td>
          <td>111.0</td>
          <td>85.0</td>
          <td>112.642091</td>
          <td>21.896309</td>
        </tr>
        <tr>
          <th>AAATGGTCAATGTGCC-1</th>
          <td>146.0</td>
          <td>113.0</td>
          <td>84.0</td>
          <td>113.296553</td>
          <td>24.740431</td>
          <td>112.0</td>
          <td>77.0</td>
          <td>53.0</td>
          <td>80.073602</td>
          <td>22.858352</td>
          <td>144.0</td>
          <td>113.0</td>
          <td>89.0</td>
          <td>115.193915</td>
          <td>20.901613</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 72-76

To visualize the features, we can use :func:`squidpy.pl.extract` to plot the texture features on the tissue image.

Here, we plot the median values of all channels (`summary_ch-0_quantile-0.5`,
`summary_ch-0_quantile-0.5`, and `summary_ch-2_quantile-0.5`).

.. GENERATED FROM PYTHON SOURCE LINES 76-81

.. code-block:: default

    sc.pl.spatial(
        sq.pl.extract(adata, "features"),
        color=["summary_ch-0_quantile-0.5", "summary_ch-0_quantile-0.5", "summary_ch-2_quantile-0.5"],
    )




.. image-sg:: /auto_examples/image/images/sphx_glr_compute_features_002.png
   :alt: summary_ch-0_quantile-0.5, summary_ch-0_quantile-0.5, summary_ch-2_quantile-0.5
   :srcset: /auto_examples/image/images/sphx_glr_compute_features_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 82-101

Specify crop appearance
=======================
Features are extracted from image crops that capture the Visium spots
(see also :ref:`sphx_glr_auto_examples_image_compute_crops.py`).
By default, the crops have the same size as the spot, are not scaled and square.
We can use the ``mask_circle`` argument to mask a circle and ensure that only tissue underneath the round
Visium spots is taken into account to compute the features.
Further, we can set ``scale`` and ``spot_scale`` arguments to change how the crops are generated.
For more details on the crop computation, see also :ref:`sphx_glr_auto_examples_image_compute_crops.py`.

  - Use ``mask_circle = True, scale = 1, spot_scale = 1``, if you would like to get features that are calculated
    only from tissue in a Visium spot.
  - Use ``scale = X``, with `X < 1`, if you would like to downscale the crop before extracting the features.
  - Use ``spot_scale = X``, with `X > 1`, if you want to extract crops that are X-times the size of the Visium spot.

Let us extract masked and scaled features and compare them.

We subset ``adata`` to the first 50 spots to make the computation of features fast.
Skip this step if you want to calculate features from all spots.

.. GENERATED FROM PYTHON SOURCE LINES 101-138

.. code-block:: default

    adata_sml = adata[:50].copy()

    # calculate default features
    sq.im.calculate_image_features(
        adata_sml, img, features=["summary", "texture", "histogram"], key_added="features", show_progress_bar=False
    )
    # calculate features with masking
    sq.im.calculate_image_features(
        adata_sml,
        img,
        features=["summary", "texture", "histogram"],
        key_added="features_masked",
        mask_circle=True,
        show_progress_bar=False,
    )
    # calculate features with scaling and larger context
    sq.im.calculate_image_features(
        adata_sml,
        img,
        features=["summary", "texture", "histogram"],
        key_added="features_scaled",
        mask_circle=True,
        spot_scale=2,
        scale=0.5,
        show_progress_bar=False,
    )

    # plot distribution of median for different cropping options
    _ = sns.displot(
        {
            "features": adata_sml.obsm["features"]["summary_ch-0_quantile-0.5"],
            "features_masked": adata_sml.obsm["features_masked"]["summary_ch-0_quantile-0.5"],
            "features_scaled": adata_sml.obsm["features_scaled"]["summary_ch-0_quantile-0.5"],
        },
        kind="kde",
    )




.. image-sg:: /auto_examples/image/images/sphx_glr_compute_features_003.png
   :alt: compute features
   :srcset: /auto_examples/image/images/sphx_glr_compute_features_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 139-140

The masked features have lower median values, because the area outside the circle is masked with zeros.

.. GENERATED FROM PYTHON SOURCE LINES 142-146

Parallelization
===============
Speeding up the feature extraction is easy.
Just set the ``n_jobs`` flag to the number of jobs that should be used by :func:`squidpy.im.calculate_image_features`.

.. GENERATED FROM PYTHON SOURCE LINES 146-147

.. code-block:: default

    sq.im.calculate_image_features(adata, img, features="summary", key_added="features", n_jobs=4, show_progress_bar=False)








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  56.967 seconds)

**Estimated memory usage:**  318 MB


.. _sphx_glr_download_auto_examples_image_compute_features.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: compute_features.py <compute_features.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: compute_features.ipynb <compute_features.ipynb>`
